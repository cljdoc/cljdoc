{:min-bb-version "1.3.184"
 :paths ["." "script"]
 :deps {doric/doric {:mvn/version "0.9.0"}
        lread/status-line {:git/url "https://github.com/lread/status-line.git"
                           :sha "cf44c15f30ea3867227fa61ceb823e5e942c707f"}
        dev.nubank/docopt {:mvn/version "0.6.1-fix7"}
        etaoin/etaoin {:mvn/version "1.1.42"}}
 :tasks
 {;; setup
  :requires ([babashka.fs :as fs]
             [babashka.process :as p]
             [clojure.string :as str]
             [build-shared :as bs]
             [lread.status-line :as status]
             [version])
  :enter (let [{:keys [name task-decoration] :as f} (current-task)]
           (when-not (= :none task-decoration)
             (status/line :head "TASK %s" name)))
  :leave (let [{:keys [name task-decoration] :as f} (current-task)]
           (when-not (= :none task-decoration)
             (status/line :detail "\nTASK %s done." name)))

  ;; commands
  clean
  {:doc "delete all build work"
   :task (do
           (println "Deleting (d=deleted -=did not exist)")
           (run! (fn [d]
                   (println (format "[%s] %s"
                                    (if (fs/exists? d) "d" "-")
                                    d))
                   (fs/delete-tree d))
                   ["target"
                    "resources-compiled"
                    ".cpcache"
                    ".parcel-cache"
                    "modules/deploy/.cpcache"]))}
  download-deps
  {:doc "download clojure deps"
   :task (clojure "-T:build download-deps")}
  deps-js
  {:doc "bring down js deps"
   :task (if (seq (fs/modified-since "node_modules" ["package-lock.json"]))
           (shell "npm ci")
           (println "Skipped npm ci: package-lock.json older than node_modules"))}
  compile-js
  {:doc "compile front end sources"
   :depends [deps-js]
   :task (let [out-dir "resources-compiled/public/out"]
           (if (seq (fs/modified-since out-dir ["resources/public" "js"]))
             (shell "npm run build")
             (println "Skipped: JS assets already compiled to" out-dir)))}
  compile-js-watch
  {:doc "compile front end sources and watch for changes"
   :depends [deps-js]
   :task (p/exec "npm run dev")}
  code-format-js
  {:doc "(check|fix) JS code format"
   :depends [deps-js]
   :task (let [cmd (first *command-line-args*)]
           (if (= cmd "fix" )
             (do (println "fixing")
                 (shell "npm run format"))
             (do (println "checking")
                 (shell "npm run lint"))))}
  compile-java
  {:doc "Compile java sources"
   :task (if (seq (fs/modified-since bs/class-dir (fs/glob "." "src/**.java")))
           (clojure "-T:build" "compile-java")
           (println "Java sources already compiled to" bs/class-dir))}
  lint-js
  {:doc "lint typescript"
   :depends [deps-js]
   :task (let [exit (-> (shell {:continue true} "npx tsc") :exit)]
           (if (zero? exit)
             (println "Exited with 0, so all seems good.")
             (System/exit exit)))}
  eslint
  {:doc "eslint typescript"
   :depends [deps-js]
   :task (let [exit (-> (apply shell {:continue true} "npx eslint" *command-line-args*) :exit)]
           (if (zero? exit)
             (println "No eslint errors detected")
             (System/exit exit)))}
  server
  {:doc "Launch cljdoc server"
   :depends [deps-js compile-js compile-java]
   :task (apply clojure "-M:cli run" *command-line-args*)}
  ingest
  {:doc "Ingest docs locally for testing"
   :depends [compile-java]
   :task (apply clojure "-M:cli ingest" *command-line-args*)}
  test
  {:doc "Run tests"
   :depends [deps-js compile-js compile-java]
   :task (apply clojure "-M:test" *command-line-args*)}
  lint
  {:doc "[--rebuild] lint source code using clj-kondo"
   :task lint/-main}
  eastwood
  {:doc "lint source code using eastwood"
   :depends [compile-java]
   :task (clojure "-M:test:eastwood")}
  code-format
  {:doc "(check|fix) check whitespace formatting"
   :task code-format/-main}
  current-version
  {:doc "print current version"
   :task-decoration :none ;; some users might want us raw output
   :task version/-main}
  package
  {:doc "Zip up cljdoc for docker"
   :requires [package]
   ;; this check supports current CI job pipeline which relies on not having to recreate cljdoc.zip
   :task (if (fs/exists? "target/cljdoc.zip")
           (println "Skipped: target/cljdoc.zip exists")
           (do
             (run 'compile-js)
             (run 'compile-java)
             (apply package/-main *command-line-args*)))}
  docker-image
  {:doc "Create docker image"
   :depends [package]
   :task (shell {:dir "ops/docker"}
                "bb image.clj" (fs/absolutize "target/build/cljdoc.zip") (version/version))}
  outdated
  {:doc "report on outdated Clojure and JavaScript dependencies"
   :depends [deps-js]
   :task outdated/-main}
  doc-update-readme
  {:doc "honour our contributors in README"
   :task doc-update-readme/-main}
  check-contributors
  {:doc "who'd we miss?"
   :task check-contributors/-main}
  nvd-scan
  {:doc "Scan Clojure deps for vulnerabilities"
   :task (let [cp (with-out-str (clojure "-Spath -M:cli"))]
           ;; nvd-clojure docs have a strong opinion that nvd-scan should be run from it own dir
           (clojure {:dir "./modules/nvd-scan"}
                    "-J-Dclojure.main.report=stderr -M -m nvd.task.check"
                    "./nvd-config.edn"
                    cp))}

  deploy
  {:doc "ops: Deploy to Production (run by CircleCI)"
   :task (let [cljdoc-version (-> (shell {:out :string} "bb current-version") :out str/trim)]
           (status/line :detail "Deploying cljdoc version %s" cljdoc-version)
           (apply shell {:dir "ops/exoscale/deploy"}
                  "clojure -M -m cljdoc.deploy deploy -t" cljdoc-version
                  *command-line-args*))}}}
